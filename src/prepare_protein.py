#!/usr/local/miniconda3/bin/python

import os
import re
import sys
import getopt
import numpy
import scipy
import dotenv
import parmed
import pytraj
import pathlib
import itertools
import subprocess
import scipy.spatial
import subprocess as sp

def pytraj_detect_Reduce_HIX(top):
    '''
    Function taking in pytraj.top for detecting HIX of pdb file generated by Reduce.
    '''
    r_HIS = filter(lambda x: x.name == 'HIS', top.residues)
    
    def gen_HIX(r_HIS):
        for r in r_HIS:
            resname = r.name
            resid = str(r.original_resid)
            atoms = [top.atom(idx) for idx in range(r.first_atom_index, r.last_atom_index, 1)]
        
            Have_HD1 = True if len(list(filter(lambda x: x.name == 'HD1', atoms))) > 0 else False
            Have_HE2 = True if len(list(filter(lambda x: x.name == 'HE2', atoms))) > 0 else False
                
            if Have_HD1 and Have_HE2:
                yield (resname, resid, 'HIP')
            elif Have_HD1:
                yield (resname, resid, 'HID')
            elif Have_HE2:
                yield (resname, resid, 'HIE')
                
    return list(gen_HIX(r_HIS))

def pytraj_detect_disulfide_bond(top, xyz):
    '''
    xyz: 2D ndarray
    '''
    ########################################################################################
    r_CYS = filter(lambda x: x.name == 'CYS', top.residues)
    
    def gen_SGs(r_CYS):
        for r in r_CYS:
            atoms = [(top.atom(idx), idx) for idx in range(r.first_atom_index, r.last_atom_index, 1)]
            yield list(filter(lambda x: x[0].name == 'SG', atoms))[0]
    SGs = list(gen_SGs(r_CYS))
    SGs = [(atom, xyz[idx]) for atom, idx in SGs]
    
    ########################################################################################
    def gen_disulfide_bonded_SG(SGs):
        cutoff = 3.0 # disulfide bond cutoff
        
        if len(SGs) == 0:
            return
        
        SGs_xyz = numpy.array(list(zip(*SGs))[1])
        dis_m = scipy.spatial.distance.pdist(SGs_xyz)
        dis_m_index = list(zip(*numpy.triu_indices(SGs_xyz.shape[0], 1)))
        
        for idx in numpy.argwhere(dis_m < cutoff).reshape(-1):
            i, j = dis_m_index[idx]
            yield SGs[i], SGs[j]
    SGs_bonded = list(gen_disulfide_bonded_SG(SGs))
    
    ########################################################################################
    def gen_CYX(SGs_bonded):
        for atom1, atom2 in SGs_bonded:
            atom1_resname = atom1[0].resname
            atom1_resid = top.residue(atom1[0].resid).original_resid
            atom2_resname = atom2[0].resname
            atom2_resid = top.residue(atom2[0].resid).original_resid
            #atom2_name = atom2[0].name
            yield (atom1_resname, atom1_resid, 'CYX')
            yield (atom2_resname, atom2_resid, 'CYX')
    CYXs = list(gen_CYX(SGs_bonded))
    
    def gen_disulfide_bond(SGs_bonded):
        for atom1, atom2 in SGs_bonded:
            atom1_resid = top.residue(atom1[0].resid).original_resid
            atom1_name = atom1[0].name
            atom2_resid = top.residue(atom2[0].resid).original_resid
            atom2_name = atom2[0].name
            yield ((atom1_resid, atom1_name), (atom2_resid, atom2_name))
    disulfide_bonds = list(gen_disulfide_bond(SGs_bonded))
    
    return CYXs, disulfide_bonds

def Propka_load_propka(pka_file):
    
    ########################################################################################
    with open(pka_file, 'r') as f:
        pka_text = f.read()
    
    ########################################################################################
    """
    To match a newline, or "any symbol" without re.S/re.DOTALL, you may use any of the following:
    
    [\s\S]
    [\w\W]
    [\d\D]
    """
        
    pat_begin = '''\
---------  -----   ------   ---------------------    --------------    --------------    --------------
                            DESOLVATION  EFFECTS       SIDECHAIN          BACKBONE        COULOMBIC    
 RESIDUE    pKa    BURIED     REGULAR      RE        HYDROGEN BOND     HYDROGEN BOND      INTERACTION  
---------  -----   ------   ---------   ---------    --------------    --------------    --------------
'''

    pat_end = '''\
--------------------------------------------------------------------------------------------------------
SUMMARY OF THIS PREDICTION
'''

    pattern = re.compile(r'(?<={pat_begin})([\s\S.]+?)(?={pat_end})'.format(pat_begin=pat_begin, pat_end=pat_end))
    match = re.finditer(pattern, pka_text)
    data = list(match)[0].group().split('\n')
    data = filter(lambda x: len(x) == 103, data)
    
    ########################################################################################
    column_RESIDUE = slice(0,9)
    column_pKa = slice(10,16)
    column_BURIED = slice(17,25)
    column_DESOLVATION_EFFECTS = slice(26,49)
    column_SIDECHAIN_HYDROGEN_BOND = slice(50,67)
    column_BACKBONE_HYDROGEN_BOND = slice(68,85)
    column_COULOMBIC_INTERACTION = slice(86,103)
    
    data = [(line[column_RESIDUE].strip(),
             line[column_pKa].strip(),
             line[column_BURIED].strip(),
             line[column_DESOLVATION_EFFECTS].strip(),
             line[column_SIDECHAIN_HYDROGEN_BOND].strip(),
             line[column_BACKBONE_HYDROGEN_BOND].strip(),
             line[column_COULOMBIC_INTERACTION].strip(),
            ) for line in data]
    
    def gen_parse_data(data):
        data = [list(g) for k, g in itertools.groupby(data, lambda x: x[0])]
        for group in data:
            RESIDUE = group[0][0]
            pKa = group[0][1]
            BURIED = group[0][2]
            DESOLVATION_EFFECTS = group[0][3]
            SIDECHAIN_HYDROGEN_BOND = list(filter(lambda x: x.split()[1] != 'XXX', [item[4] for item in group]))
            BACKBONE_HYDROGEN_BOND = list(filter(lambda x: x.split()[1] != 'XXX', [item[5] for item in group]))
            COULOMBIC_INTERACTION = list(filter(lambda x: x.split()[1] != 'XXX', [item[6] for item in group]))
            yield (RESIDUE, pKa, BURIED, DESOLVATION_EFFECTS, SIDECHAIN_HYDROGEN_BOND, BACKBONE_HYDROGEN_BOND, COULOMBIC_INTERACTION)
    data = list(gen_parse_data(data))
    
    return [PropkaResidue(r[0], r[1], r[2], r[3], r[4], r[5], r[6]) for r in data]

class PropkaResidue(object):
    def __init__(self, RESIDUE, pKa, BURIED, DESOLVATION_EFFECTS, SIDECHAIN_HYDROGEN_BOND, BACKBONE_HYDROGEN_BOND, COULOMBIC_INTERACTION):
        self._RESIDUE = RESIDUE
        self._pKa = pKa
        self._BURIED = BURIED
        self._DESOLVATION_EFFECTS = DESOLVATION_EFFECTS
        self._SIDECHAIN_HYDROGEN_BOND = SIDECHAIN_HYDROGEN_BOND
        self._BACKBONE_HYDROGEN_BOND  = BACKBONE_HYDROGEN_BOND
        self._COULOMBIC_INTERACTION = COULOMBIC_INTERACTION
        
    @property
    def resname(self):
        return self._RESIDUE.split()[0]
        
    @property
    def resid(self):
        return self._RESIDUE.split()[1]
        
    @property
    def chain(self):
        return self._RESIDUE.split()[2]
    
    @property
    def pKa(self):
        return float(self._pKa)
    
    def Amber_protonation_state(self, pH=7.0):
        # Histidine
        if self.resname == 'HIS':
            if self.pKa > pH:
                return 'HIP'
            else:
                return 'HIS'
        
        # Aspartate
        if self.resname == 'ASP':
            if self.pKa > pH:
                return 'ASH'
            else:
                return 'ASP'
        
        # Glutamate
        if self.resname == 'GLU':
            if self.pKa > pH:
                return 'GLH'
            else:
                return 'GLU'
        
        # lysine
        if self.resname == 'LYS':
            if self.pKa < pH:
                return 'LYN'
            else:
                return 'LYS'
            
        return self.resname

def Propka_get_propka_Amber_protonation_state(propka_pka):
    propka_residues = list(Propka_load_propka(propka_pka))
    
    # enviromental pH
    PH = 7.0
    
    # non default protonation states in Amber
    RESNAMES = ['HIP', 'ASH', 'GLH', 'LYN']
    
    # the name for N terminus amine group and 
    # C terminus carboxylic group 
    NTERM_NAME = 'N+'
    CTERM_NAME = 'C-'
    
    N_term_residues = list(filter(
        lambda r: r.resname == NTERM_NAME, propka_residues))
    C_term_residues = list(filter(
        lambda r: r.resname == CTERM_NAME, propka_residues))
    
    # pick residues of which the protonation state should be modified
    picked_residues = list(filter(
        lambda r: r.Amber_protonation_state(pH=PH) in RESNAMES,
        propka_residues))
    
    # C-terminal GLH is not present in standard AMBER forcefields
    picked_residues = list(filter(
        lambda r: r.resid not in [x.resid for x in C_term_residues],
        picked_residues))
    
    
    def gen_protonation_state(picked_residues):
        for r in picked_residues:
            resname = r.resname
            resid = r.resid
            protonation_state = r.Amber_protonation_state(pH=PH)
            yield (resname, resid, protonation_state)
    modified_residues = list(gen_protonation_state(picked_residues))
            
    return modified_residues

class ParmEdPDBResnameModifier(object):
    """
    
    """
    def __init__(self, struct):
        self._struct = struct
        self._modifications = dict()
    
    @property
    def modifications(self):
        return self._modifications.copy()
    
    def add_modifications(self, new_modifications):
        '''
        new_modification:
            ex:
                [('GLU', '471', 'GLH'), ('HIS', '468', 'HIP')]
        '''
        self._modifications.update([((item[0], item[1]), item[2]) for item in new_modifications])
        
    def apply_modifications(self):
        import parmed
        
        struct = self._struct.copy(parmed.structure.Structure)
        struct_df = struct.to_dataframe()
        
        for item in self._modifications.items():
            resname = item[0][0]
            resnum = int(item[0][1])
            new_resname = item[1]
            
            r = struct.view[(struct_df.resname == resname) & (struct_df.resnum == resnum)].residues[0]
            r.name = new_resname
        
        return struct

def Tleap_bond_command(object_name, disulfide_bonds):
    return ['bond {}.{}.{} {}.{}.{}'.format(object_name, atom1[0], atom1[1],
                                            object_name, atom2[0], atom2[1]) 
             for atom1, atom2 in disulfide_bonds
           ]

class Program(object):

    def __init__(self, base_folder, aux_scripts, com_tokens):
        self.base_folder = base_folder
        self.aux_scripts = aux_scripts
        self.command = self.join_tokens(com_tokens)

    @staticmethod
    def write_script(script):
        filename = script[0]
        content = script[1]
        with open(filename, "w") as f:
            f.write(content)

    @staticmethod
    def join_tokens(tokens):
        tokens = [' '.join(p) for p in tokens]
        return ' '.join(tokens)

    def run(self):
        root_folder = os.getcwd()
        os.chdir(self.base_folder)

        for script in self.aux_scripts:
            self.write_script(script)
        retcode = subprocess.run(self.command, shell=True, check=False)

        os.chdir(root_folder)

        return retcode


def prepare_protein_pdb(environ, work_folder, model_pdb):

    # --------------------------------------------------------------------------------
    # output files
    image_pdb = os.path.join(work_folder,'image.pdb')
    trim_pdb = os.path.join(work_folder,'trim.pdb') # for reduce
    reduce_pdb = os.path.join(work_folder,'reduce.pdb')
    reduce_log = os.path.join(work_folder,'reduce.log')
    image_pka = os.path.join(work_folder,'image.pka')
    image_propka_input = os.path.join(work_folder,'image.propka_input')
    tleap_pdb = os.path.join(work_folder,'tleap.pdb')
    protein_parm7 = os.path.join(work_folder,'protein.parm7')
    protein_crd = os.path.join(work_folder,'protein.crd')
    protein_lib = os.path.join(work_folder,'protein.lib')
    protein_pqr = os.path.join(work_folder,'protein.pqr')
    protein_pdb = os.path.join(work_folder,'protein.pdb')
    protein_pdbqt = os.path.join(work_folder,'protein.pdbqt')

    # --------------------------------------------------------------------------------
    # Extract protein from "model.pdb".
    # Residue numbers are reorder at this stage.
    struct = parmed.load_file(model_pdb)
    #struct_df = struct.to_dataframe()
    #struct_protein = struct[struct_df.chain == 'A']
    struct.save(image_pdb, format='PDB', renumber=True, standard_resnames=True, overwrite=True)
    
    # --------------------------------------------------------------------------------
    # Run Reduce and get modificated residues.
    # Not using the flipped pdb ("reduce_pdb") in the following steps
    # to preserve the original orientation of residues.
    command = '{} -Trim {} > {} 2> {}'.format(environ['REDUCE_EXE'], image_pdb, trim_pdb, reduce_log)
    os.system(command)
    command = '{} -BUILD -FLIP {} > {} 2> {}'.format(environ['REDUCE_EXE'], trim_pdb, reduce_pdb, reduce_log)
    os.system(command)

    traj_reduce = pytraj.load(reduce_pdb)
    reduce_modifications = pytraj_detect_Reduce_HIX(traj_reduce.top)

    # --------------------------------------------------------------------------------
    # Run propka31 and get modificated residues
    command = '{} {}'.format(environ['PROPKA31_EXE'], image_pdb)
    child = sp.Popen(command.split(), stdin=sp.PIPE, stdout=sp.PIPE, stderr=sp.PIPE, cwd=work_folder)
    child.communicate()
#     os.system(command)

    propka_modifications = Propka_get_propka_Amber_protonation_state(image_pka)

    # --------------------------------------------------------------------------------
    # detect disulfide bonds and get modificated residues
    traj_image = pytraj.load(image_pdb)
    disulfide_modifications, disulfide_bonds = pytraj_detect_disulfide_bond(traj_image.top, traj_image.xyz[0])

    # --------------------------------------------------------------------------------
    # Generate modified pdb, "tleap.pdb", ready for tleap
    struct_image = parmed.load_file(image_pdb)

    M = ParmEdPDBResnameModifier(struct_image)
    M.add_modifications(reduce_modifications)
    M.add_modifications(propka_modifications)
    M.add_modifications(disulfide_modifications)
    #print(M.modifications)

    struct_tleap = M.apply_modifications()['!@H=']
    struct_tleap.save(tleap_pdb, format='PDB', overwrite=True)
    
    # --------------------------------------------------------------------------------
    # Generate "protein.pdb" and "protein.pqr" using tleap and ambpdb

    # using tleap to create parm7 and crd file
    tleap_script = '\n'.join([
        'set default PBradii mbondi2',
        'source leaprc.protein.ff14SB',
        'source leaprc.water.tip3p',
        'protein = loadpdb {}'.format(tleap_pdb),
    ] + Tleap_bond_command('protein', disulfide_bonds) + [
        'saveamberparm protein {} {}'.format(protein_parm7, protein_crd),
        'saveOff protein {}'.format(protein_lib),
        'quit'
    ])
    
    retcode = Program(
        work_folder,
        [('tleap.in', tleap_script)],
        [(environ['TLEAP_EXE'],),
         ('-f', 'tleap.in')]
    ).run()
    retcode.check_returncode()

    # using ambpdb to create pqr file
    retcode = Program(
        work_folder,
        [],
        [(environ['AMBPDB_EXE'],),
         ('-p', protein_parm7),
         ('-pqr',),
         ('-bres',),
         ('-aatm',),
         ('< {}'.format(protein_crd),),
         ('> {}'.format(protein_pqr),)]
    ).run()
    retcode.check_returncode()
    
    # using ambpdb to create pdb file
    retcode = Program(
        work_folder,
        [],
        [(environ['AMBPDB_EXE'],),
         ('-p', protein_parm7),
         ('-bres',),
         ('-aatm',),
         ('< {}'.format(protein_crd),),
         ('> {}'.format(protein_pdb),)]
    ).run()
    retcode.check_returncode()

    # --------------------------------------------------------------------------------
    # using autodocktools to create pqbqt file (NO TEST)
    retcode = Program(
        work_folder,
        [],
        [(environ['PYTHONSH_EXE'],),
         (os.path.join(environ['UTILITIES24'], 'prepare_receptor4.py'),),
         ('-r', protein_pqr),
         ('-o', protein_pdbqt),
         ('-C',)]
    ).run()
    retcode.check_returncode()

if __name__ == '__main__':

    def usage():
        print('Usage: prepare_protein.py -w work_folder -i input_pdb')
        print('\t-w:\tworking folder where all the output files will be located.')
        print('\t-i:\tinput protein in PDB format for processing.')
    
    # process command arguments
    try:
        opt_list, args = getopt.getopt(sys.argv[1:], 'w:i:')
        opt_list = dict(opt_list)
        work_folder = opt_list['-w']
        model_pdb = opt_list['-i']
    except:
        usage()
        sys.exit(2)
    
    CURRENT_DIR = pathlib.Path(__file__).resolve().parent
    BASE_DIR = CURRENT_DIR.parent
    # ENV_FILE_PATH = BASE_DIR / '.env'
    ENV_FILE_PATH = CURRENT_DIR / '.env'

    dotenv.load_dotenv(str(ENV_FILE_PATH))
    work_folder = os.path.abspath(work_folder)
    protein_folder = os.path.join(work_folder,'Protein')
    os.makedirs(protein_folder, exist_ok=True)
    
    prepare_protein_pdb(os.environ, protein_folder, model_pdb)